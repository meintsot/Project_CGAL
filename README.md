# Εργασία 2 

**Κοτσομπόλης Αθανάσιος 1115201900090**\
**Μεϊντάνης Σωτήριος 1115201900234**

## Οδηγίες εκτέλεσης

Για την μεταγλώττιση και την εκτέλεση του προγράμματος:\
```bash
mkdir build
cd build
cmake ..
make
./opt_triangulation -i ../data/<file_input> -o ../data/<file_output> 
```

Έχουμε ήδη 3 input_files, κάθε ένα κατάλληλο για την εκτέλεση του καθένα από τους 3 αλγόριθμους

Για το αρχείο CMakeLists.txt θα πρέπει να αλλάξετε την γραμμή `set(CGAL_DIR "/usr/local/lib/cmake/CGAL")` ώστε να περιλαμβάνει την τοποθεσία της CGAL στον υπολογιστή σας.

## Περιγραφή υλοποίησης

Η εργασία έχει την εξής δομή:

### data/
Περιέχει διάφορα instances σε μορφή json καθώς και το αποτέλεσμα που παράγεται από το εκτελέσιμο
Λόγω των παραμέτρων της εργασίας 2 στο json έχουμε τροποποιήσει το αρχείο της εκφώνησης ώστε να δίνεται για εκτέλεση με κάθε έναν από τους 3 αλγορίθμους ( input_ant.json / input_sa.json / input_ls.json )

### include/
Περιέχει όλα τα αρχεία επικεφαλίδας που είναι απαραίτητα για την εφαρμογή. Συγκεκριμένα τα αρχεία:
- `jsonUtils.hpp` : Περιέχει τα πρότυπα των απαιτούμενων βοηθητικών συναρτήσεων για την διαχείριση των αρχείων json. Ως βοηθητική βιβλιοθήκη χρησιμοποιήσαμε την **nlohmann**
- `triangulation.hpp` : Περιέχει όλους τους αφηρημένους τύπους για την υλοποίηση της εφαρμογής
- `triangulationUtils.hpp` : Περιέχει τα πρότυπα των απαιτούμενων βοηθητικών συναρτήσεων για την τριγωνοποίηση
- `triangulationMethod.hpp` : Περιέχει την αφηρημένη κλάση που αναφέρεται σε κάποια υλοποίηση για την ελαχιστοποίηση των steiner points. Η αρχιτεκτονική που ακολουθήσαμε στηρίζεται στο strategy pattern κατά το οποίο η κλάση **TriangulationMethod** ορίζεται ως η κοινή διεπαφή προς γενικευμένη χρήση στον κύριο κώδικα καθώς και οι επιμέρους κλάσεις με το αντίστοιχο implementation που ορίζονται παρακάτω.
- `circumCenterMethod.hpp` : Περιέχει την implementation κλάση που υλοποιεί την μέθοδο circumCenterMethod
- `midpointMethod.hpp` : Περιέχει την implementation κλάση που υλοποιεί την μέθοδο midpointMethod
- `centroidMethod.hpp` : Περιέχει την implementation κλάση που υλοποιεί την μέθοδο CentroidMethod
- `projectionMethod.hpp` : Περιέχει την implementation κλάση που υλοποιεί την μέθοδο Projection
- `oneCentroidMethod.hpp` : Περιέχει την implementation κλάση που υλοποιεί την μέθοδο oneCentroidMethod

### src/
Περιέχει τις υλοποιήσεις των παραπάνω αρχείων.
Έχουμε υλοποιήσει και τις 5 μεθόδους για εισαγωγή σημείων steiner στο αντίστοιχο .cpp αρχείο που χρησιμοποιούνται από τους 3 αλγορίθμους που είναι υλοποιημένοι στο αρχείο algorithms.cpp

Για τον αλγόριθμο **Local Search** κοιτάμε σε κάθε βήμα ποια από τις 5 μεθόδους δίνει το καλύτερο αποτέλεσμα ( δηλαδή μειώνει περισσότερο τα αμβλυγώνια τρίγωνα ) και επιλέγουμε αυτήν για να εκτελεστεί. Η διαδικασία αυτή σταματάει όταν δεν υπάρχει δυνατότητα για περαιτέρω βελτίωση.
Μειώθηκαν στα 11 αμβλυγώνια τα τρίγωνα με αυτόν τον αλγόριθμο.

Για τον αλγόριθμο **Simulated Annealing** ακολουθήσαμε τον ψευδοκώδικα των διαφανειών και παρατηρήσαμε ότι για χαμηλές τιμές του b έμπαιναν πολλά σημεία steiner καθώς είχε μικρό penalty ο τύπος για την Ενέργεια, και αυτό οδηγούσε σε πολύ χρονοβόρες εκτελέσεις γιατί ο γράφος γινόταν υπερβολικά περίπλοκος με πολλά σημεία. Μετά από δοκιμές καταλήξαμε ότι με a=3.5, b=1.0, L=500 παίρναμε καλά αποτελέσματα σε σταθερό χρόνο, οπότε κρατήσαμε αυτές τις τιμές.
Εδώ είχαμε τα καλύτερα αποτελέσματα, περίπου 15% των εκτελέσεων είχαμε κάτω από 5 αμβλυγώνια ( μερικές φορές 2 και μια φορά 1 μόνο ), 70% ήταν από 6-9 αμβλυγώνια και 15% 10-12 αμβλυγώνια.

Για τον αλγόριθμο **Ant Colony Optimization** ακολουθήσαμε τον ψευδοκώδικα των διαφανειών και αντιθέτως με τον SA, οι μικρές τιμές του b δίναν καλύτερα αποτελέσματα καθώς εδώ θέλουμε περισσότερα steiner points.
Για το evaportaion rate επιλέξαμε να είναι 0.5, οι κύκλοι 50 και τα ants 10.
Εδώ είχαμε χειρότερα αποτελέσματα από τον SA, στις περισσότερες περιπτώσεις τα αμβλυγώνια που προέκυπταν ήταν από 12 εώς 15. Λίγες φορές από 9-12 και επίσης λίγες φορές από 15-17.

Για την delaunay = 1 δεν χρειάζεται να τρέχουμε την εργασία 1 ξανά, καθώς η local_search είναι ουσιαστικά μια παραλαγή της εργασίας 1, οπότε απλώς καλούμε την συνάρτηση και επιστρέφει το έτοιμο cdt για να συνεχίσει η εκτέλεση. 

Εργασία 3

Για τις δοκιμές σε κάθε μέθοδο βάλαμε χρονικό όριο 60 δευτερόλεπτα, ώστε να γίνεται timeout σε περίπτωση που ο αλγοριθμός κρατάει πάνω από 1 λεπτό.

Για όλους τις μεθόδους χρησιμοποιούμε τις παραμέτρους (a,b,xi,psi,etc) της εργασίας 2, καθώς και εδώ είδαμε παρόμοια συμπεριφορά με τις δοκιμές στις παραμέτρους



Για την κατηγορία "**Δ. Μη κυρτό boundary με ευθύγραμμα τμήματα παράλληλα στους άξονες χωρίς
περιορισμούς**" είδαμε ότι η καλύτερη μέθοδος ήταν η Local Search, κάτι που επιβεβαιώνεται βλέποντας τα αποτελέσμτα στα μεγάλα instances όπου καταλήγει σε τριγωνοποίηση με λιγότερα αμβλυγώνια από την SA, αλλά και με αρκετά μικρότερο αριθμό από steiner points 


![alt text](Non_Convex_Parallel.png)

![alt text](Non_Convex_Parallel_fix.png)

Για την κατηγορία "**Ε. Μη κυρτό boundary, ακανόνιστο, που δεν εντάσσεται στις κατηγορίες Α-Δ**" τα αποτελέσματα ήταν παρόμοια με την Δ, που είναι λογικό καθώς είναι αρκετά παρόμοιες κατηγορίες. Και εδώ παρατηρείται το ίδιο φαινόμενο. Για τα πιο μικρά instances η SA έχει τα λιγότερα αμβλυγώνια αλλά με πολλά steiner points, αλλά όσο μεγαλώνουν τα instances η Local Search έχει τα λιγότερα αμβλυγώνια και με αρκετά λιγότερα steiner points

![alt text](Non_Convex_Irregular.png)

![alt text](Non_Convex_Irregular2.png)